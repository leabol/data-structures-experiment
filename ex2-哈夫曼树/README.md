# 哈夫曼树编解码系统

## 项目介绍

本项目实现了基于哈夫曼编码的文本压缩与解压系统。通过构建哈夫曼树，根据字符出现频率为每个字符设计不同长度的编码，从而实现对文本内容的有效压缩。

## 项目结构

```
├── main.c          // 主程序逻辑
├── huffman.c       // 哈夫曼树编码与解码实现
├── huffman.h       // 哈夫曼树相关函数定义
├── pri_queue.c     // 优先队列实现（基于最小堆）
├── pri_queue.h     // 优先队列函数定义
├── read_file.c     // 文件读取和处理函数
├── read_file.h     // 文件处理函数定义
├── sort.h          // 排序算法定义
├── Makefile        // 项目构建脚本
├── text1           // 示例输入文件
├── write           // 编码后的输出文件
├── decode          // 解码后的还原文件
```

## 核心功能

1. **频率统计**：读取文本文件并统计每个字符出现的频率
2. **构建哈夫曼树**：基于字符频率构建哈夫曼树
3. **生成编码表**：根据哈夫曼树为每个字符生成唯一的编码
4. **文本编码**：使用编码表将原文本编码压缩
5. **文本解码**：使用哈夫曼树将编码后的文本还原

## 编译与运行

### 编译项目

```bash
make
```

### 运行程序

```bash
./main
```

注：程序默认以`text1`为输入文件，编码结果保存为`write`，解码结果保存为`decode`。

## 算法说明

1. **哈夫曼树构建算法**
   - 统计每个字符的频率
   - 使用优先队列（最小堆）管理节点
   - 每次从队列取出两个最小频率的节点，合并为一个新节点
   - 重复上述过程直到队列中只剩一个节点，即哈夫曼树的根节点

2. **规范哈夫曼编码生成**
   - 按编码长度排序所有字符
   - 从最短编码开始，依次递增生成编码
   - 相同长度的编码顺序递增，不同长度的编码左移补0

3. **编码与解码过程**
   - 编码：按位写入二进制文件，并记录必要的元数据
   - 解码：遍历哈夫曼树，以叶节点输出对应字符

## 性能与优化

- 使用最小堆实现的优先队列，提高了哈夫曼树构建效率
- 采用规范哈夫曼编码算法，确保前缀编码的唯一性
- 位操作处理二进制数据，节省存储空间
- 错误处理机制增强了程序的鲁棒性

## 扩展功能

- 支持UTF-8编码的多语言文本
- 文件头部保存元数据，便于准确解码
- 可处理大文件，具有良好的内存管理